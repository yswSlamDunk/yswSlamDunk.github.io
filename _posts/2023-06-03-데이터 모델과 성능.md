---
layout : single
title : "[SQLD] 02. 데이터 모델과 성능"
categories : [Certificate, SQLD]
tag : [정규화, 함수적종속, 반정규화 분산 데이터베이스]
---

## 데이터 모델과 성능
### 정규화
* 정규화는 데이터를 분해하는 과정
* 데이터 중복을 제거하여 데이터 모델의 독립성을 확보하기 위한 방법
* 정규화를 통해 데이터 모델의 유연성을 제고되어, 비즈니스 변화에 의한 데이터 모델의 변경을 최소화 
* 제 1~5 정규화까지 있으나, 실질적으로 제 3정규화까지 수행
__정규화의 장점__
* 만약 계좌 테이블가 20 개의 칼럼으로 이루어져 있고, 정규화가 되지 않았다면, 데이터의 중복으로 문제가 나타남
* 데이터베이스 관리 시스템의 입출력 단위인 블록의 크기(Block Size)를 넘어서게 되어 문제 발생 가능
* 하나의 행을 읽기 위해 여러 개의 블록 크기를 읽게되어 디스크 입출력이 증가하기 때문에 성능저하 밯생

### 제1정규화
* 정규화는 함수적 종속성을 근거로 진행
    __함수적 종속성이란__
    * 어떤 릴레이션 R이 있을때 X와 Y를 각각 속성의 부분집합이라고 가정 
    * 이 때, X의 값을 알면 Y값을 바로 식별할 수 있고, X 값에의해 Y의 값이 달라질 때, Y는 X에 함수적 종속이라 표현
    * 위의 경우, X가 Y의 결정자
    * '학번', '이름', '나이', '성별', '전공명', '전공코드' 속성을 가진 테이블의 경우, '학번'을 알면 '이름', '나이', '성별' 식별 가능
    * '전공'을 알면 '전공코드' 식별 가능
    * 위의 경우, '이름', '나이', '성별' 속성은 '학번' 속성에 함수적 종속관계, '전공코드'는 '전공'에 함수적 종속 관계
* 제1정규화는 기본키를 잡는 것
    * 기본키를 잡기 위해선 최소성, 대표성, 유일성, 불변성을 만족해야 함
    
### 제2정규화
* 제2정규화는 기본키가 두 개 이상인 경우 대상이 됨
* 기본키가 하나의 칼럼으로 이루어지면 제2정규화 생략
* 제2정규화는 부분 함수 종속성인 경우 진행
* '수강생번호', '성명', '전화번호', '수강과목', '담당선생님', '성적' 속성을 가지며, '수강생번호', '수강과목'을 기본키로 가지는 테이블을 예시로 사용
* '수강생번호'가 변화되면 '성명', '전화번호'가 변경되며, '수강과목'이 변경되면 '담당선생님'이 변경됨
* 제2정규화을 진행하면 아래의 3개의 테이블로 나눠짐
    1. '수강생번호', '성명', '전화번호' 테이블
    2. '수강과목', '담당선생님' 테이블
    3. '수강생번호', '수강과목', '성적' 테이블

### 제3정규화
* 제3정규화는 기본키를 제외하고 칼럼간의 종속성이 발생하는 현상인, 이행 함수 종속성을 제거
* 제2정규화를 완료한 '이름', '수업', '과목코드' 속성 구성되었으며, 기본키는 '이름' 속성인 테이블을 예시로 사용
* '수업'-> '과목코드'로 '과목코드'는 '수업' 속성의 함수적 종속이다.
* 제3정규화 결과 아래의 2개의 테이블로 나눠짐
    1. '이름', '수업' 테이블
    2. '이름', '과목코드' 테이블

### BCNF(Boyce-Codd Normal Form)
* BCNF는 복수의 후보키가 있고, 후보키들이 복합 속성이어야 하며, 서로 중첩인 경우 적용
* 제3정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분리하는 것
* '학번', '과목', '교수' 테이블을 예시로 사용
* 다음과 같은 제약사항이 있다고 가정
    1. 한 학생은 동일 과목에 대해 하나의 교수에게만 수강 가능
    2. 각 교수는 하나의 과목만 담당할 수 있음
    3. 한 과목은 여러 교수가 담당 가능
* ('학번' + '과목')은 교수를 결정
* 교수는 과목을 결정
* 교수 또한 결정자인데, 교수는 학번을 결정 지을 수 없으므로 후보키가 아님
* BCNF 결과 아래의 2개의 테이블로 나눠짐
    1. '학번', '과목코드' 테이블
    2. '과목코드', '과목', '교수' 테이블

### 정규화의 문제점
* 정규화는 데이터조회(Select)시 조인(Join) 연산을 유발하기 때문에 CPU와 메모리를 많이 사용
* 조인을 할수록 이중 for문이 생겨나는 현상 발생
* 데이터양이 증가하면 비굫야 하는 건수도 증가하여 비효율 발생
* 이러한 문제를 해결하기 위해 인덱스와 옵티마이저(Optimizer) 사용
* 정규화의 문제점을 해결하기 위해서 반정규화를 하여 하나의 테이블에 저장한다면 조인을 통한 성능저하 해결 가능

### 반정규화
* 데이터베이스의 성능 향상을 위해, 데이터 중복을 허용하고 조인을 줄이는 데이터베이스 성능 향상 방법
* 반정규화를 통해 Select의 속도는 향상하지만, 데이터 모델의 유연성 감소

__반정규화를 수행하는 경우__
* 정규화에 충실하여 종속성, 활용성은 향상되었지만 수행속도가 느려진 경우
* 다량의 범위를 자주 처리해야하는 경우
* 특정 범위의 데이터만 자주 처리하는 경우
* 요약/집계 정보가 자주 요구되는 경우

### 반정규화 기법
* 계산된 컬럼 추가
    * 요약/집계 정보가 자주 요구되는 경우, 사용마다 계산하는 것이 아닌, 미리 계산하여 테이블로 만들어 놓은 방안
* 테이블 수직 분할
    * 하나의 테이블을 두 개 이상의 테이블로 분할하는 방안으로, 칼럼을 분할하여 생성
* 테이블 수평 분할  
    * 하나의 테이블에 있는 값을 기준으로 테이블을 분할하는 방법
    * 예를 들어, 년도가 2020년 이전 테이블, 이후 테이블로 나누는 방법
* 테이블 병합(3가지)
    * 1대1 관계의 테이블을 하나의 테이블로 병합해서 성능을 향상시키는 방법
    * 1대N 관계의 테이블을 병합하여 성능 향상 방법
    * 슈퍼 타입과 서브 타입 관계가 발생하면 테이블을 통합하여 성능 향상
        * 고객 엔터티는 개인고객과 법인고객으로 분류됨
        * 필요에따라 고객 엔터티와 개인고객 병합

### 분산 데이터베이스
__데이터베이스의 구조__
* 중앙 집중형 데이터베이스
    * 한대의 물리적 시스템에서 데이터베이스 관리 시스템 설치하고 여러 명의 사용자가 데이터베이스 관리 시스템에 접속하여 작업 수행
* 분산 데이터베이스
    * 문리적으로 떨어진 데이터베이스에 네트워크로 연결하여 단일 데이터베이스처럼 작업을 수행

__분산 데이터베이스의 투명성__
* 분산 데이터베이스 사용자는 분산 데이터베이스 이용에 대해 인식하지 못하면서, 자신의 데이터베이스를 사용하는 것처럼 서비스를 제공해야함(투명성)
* 분할 투명성
    * 사용자가 논리적 릴레이션이 여러 단편으로 분할되어 있음을 인식할 필요 없음
* 위치 투명성
    * 고객이 사용하는 데이터의 저장장소 명시 필요 없음
    * 어느 위치에 있더라도 동일한 수행 필요
* 지역 사상 투명성
    * 각 지역 시스템 이름과 무고나한 이름이 사용 가능
* 중복 투명성
    * 여러 시스템에 중복되어 존재함에도 고객과는 무관하게 데이터의 일관성이 유지 필요
* 장애 투명성
    * 통신망에 이상이 발생해도, 데이터의 무결성은 보장 필요
* 병행 투명성
    * 여러 응용프로그램이 동시에 분산 데이터베이스에 대한 트랜잭션을 수행해도 결과에 이상 없어야 함

__분산 데이터베이스 설계 방식__
* 상향식 설계 방식
    * 지역 스키마 작성 후 향후 전역 스키마를 작성하여 분산 데이터베이스 구축
* 하향식 설계 방식
    * 전역 스키마 작성 후 해당 지역 사상 스키마를 작성하여 분산 데이터베이스 구축
    * 기업이 여러 종류의 데이터베이스 관리 시스템이 있으면, 데이터베이스 미들웨어(ODBC, JDBC)를 사용하여 이기종 데이터베이스 관리 시스템으로 연동 필요